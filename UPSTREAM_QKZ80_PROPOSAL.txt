Proposal for qkz80 CPU Emulator - Virtual I/O Port Methods
==========================================================

The qkz80 Z80 CPU emulator would benefit from virtual methods for I/O port
operations, allowing subclasses to implement machine-specific I/O handling.

Current Problem:
----------------
The IN (0xDB) and OUT (0xD3) instructions have hardcoded behavior in execute():
- OUT to port 0x11 writes to stdout
- IN from port 0x10 returns legacy 2SIO status

This makes it difficult to use qkz80 for different machine emulations without
modifying the base class.

Proposed Change:
----------------
Add virtual methods that subclasses can override:

In qkz80.h, add after execute() declaration:

  // I/O port operations - override in subclass to intercept
  virtual void port_out(qkz80_uint8 port, qkz80_uint8 value);
  virtual qkz80_uint8 port_in(qkz80_uint8 port);

Also add virtual destructor:

  virtual ~qkz80() = default;

In qkz80.cc, change the IN/OUT cases to call these methods:

  case 0xd3: // OUT
  {
    qkz80_uint8 port(pull_byte_from_opcode_stream());
    qkz80_uint8 rega(get_reg8(reg_A));
    port_out(port, rega);
    trace->asm_op("out 0x%0x",port);
    trace->add_reg8(reg_A);
    return;
  }

  case 0xdb: // IN
  {
    qkz80_uint8 port(pull_byte_from_opcode_stream());
    trace->asm_op("in 0x%0x",port);
    qkz80_uint8 dat = port_in(port);
    set_reg8(dat,reg_A);
    return;
  }

Add default implementations at end of qkz80.cc:

  // Default I/O port implementations - override for machine-specific behavior
  void qkz80::port_out(qkz80_uint8 port, qkz80_uint8 value) {
    (void)port;
    (void)value;
    // No-op by default - subclass provides machine-specific I/O
  }

  qkz80_uint8 qkz80::port_in(qkz80_uint8 port) {
    (void)port;
    // Return 0xFF (floating bus) by default
    return 0xFF;
  }

Benefits:
---------
1. Clean separation: CPU emulation has no machine-specific code
2. Follows existing pattern: similar to qkz80_cpu_mem subclassing for memory
3. Easy to use: just subclass qkz80 and override port_in/port_out
4. Backwards compatible: default implementations preserve existing behavior
   for simple cases

Example Usage:
--------------
class MyMachine_Z80 : public qkz80 {
public:
    MyMachine_Z80(qkz80_cpu_mem* mem) : qkz80(mem) {}

    void port_out(qkz80_uint8 port, qkz80_uint8 value) override {
        switch (port) {
        case 0x01: uart_write(value); break;
        case 0x10: bank_select(value); break;
        // ... other machine-specific ports
        }
    }

    qkz80_uint8 port_in(qkz80_uint8 port) override {
        switch (port) {
        case 0x00: return uart_status();
        case 0x01: return uart_read();
        default: return 0xFF;
        }
    }
};
